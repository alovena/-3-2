#과제1
4바이트로 알려줌  현재의 시간을 리턴해줌
8장 timeclient 가 있었는데 그걸 출력

리턴이 없는 Runnable 로 해도 됨 Callable<Void> 대신
과제 #1 서버 :1900 년 의 초를 반환해는것 !
#과제2
now.getTime() 1970년 기준 1월 1일
문제는 : now.getTime()은 Long형 8바이트에서 4바이트를 자르는것 
죽 time서버는 낮은쪽4바이트를 떼어냄
클라이언 서버
1970 -> 1900
         <-

============================================================
11장에서 non-blocking 을 이해하면끝이다.
isBound() 닫혀있더라도 한번 연결이 되있다면 true 반환
따라서 연결의 기준은
public static boolean isOpen(ServerSocket ss) {
return ss.isBound() && !ss.isClosed();
}
바운드 된적있고 닫히지않았다면 연결
============================================================
Server Sockets의 생성자 
1.포트번호
2.몇개까지 기다리게할것인가
3.자기자신의 이더넷어드레스를 씀 왜? 서버 인터페이스가 여러개 있을때 포트마다 주소개 여러개일수있다 그런경우 포트에 해당하는 주소를씀 
만약 인터페이스 여러개인데 포트번호만 사용한다면 모두다 열림
Tcp헤더에있는 포트번호는 16비트로 표현되기때문에 65535까지 표현가능
============================================================
서버는 항상24시간 대기
• Low cost
• High reliability
• Maximum throughput
• Minimum delay

운영체제->일의효율(실제 1시간동안 몇바이트를 보냇는가)
효율이란 : 1계층의 최고속도 0,1을 보냇을 경우를 말함
딜레이는 보냇다가 느리게 오는것
============================================================
HTTP를 처리하는 서버 ex) Apache 모든데이터를 처리 . 
Single-FileServer 
1600

jHTTP File 이존재해서 localhost:port/....txt 가 존재하면 파일 정보 -> else 404
============================================================
non blocking 의 핵심은 : 쓰레드 한 번 돌려서 여러명중 보낸것을 확인 또 보낼것인는사람 물어봐서 처리하고 하는방식 매 이벤트 발생을 처리하는것임
엄청나게 접속자수가 많을경우 효과가 있을 것이다.
#NonBlocking 클라이언트
non-blocking에서는 두가지가 생김 socketChanner과 bytebuffer이 생김
1.소켓채널과 바이트 버퍼는 같이 붙어있음
2.배열에 read를 쌓아둠 read이벤트가 뜨면 bytebuffered 에서 당겨오는게 끝임
position 에 대한 위치를  잘 정해야함
capacity : 100 이라면 limit는 100이하로 설정
#NonBlocking 서버
ServerSocketChannel은 서버소켓 만들고 
읽어올 친구를 selector 이라고 부름
SocketChanel 역시 selector에 등록시켜서 이벤트 처리시 채널이 읽어옴
selector의 이벤트를 할경우 key로 처리
============================================================
과제1.서버
과제2.rewind , filp알아보기! Buffer찾아보기